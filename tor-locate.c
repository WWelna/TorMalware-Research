/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 *                                  Tor-Locate
 * =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * Copyright (C) 2011, William H. Welna All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY William H. Welna ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL William H. Welna BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 */

#define Socket SOCKET
#define _WIN32_WINNT 0x0501

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <Winbase.h>
#include <time.h>
#include <sys/types.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "pstdint.h"

int http_download(char *host, char *port, char *http_host, char *path, char *localfile, int attributes);
int ipv4_connect(char *host, char *port);
int ipv4_close(int sock);
int socks5_check(char *proxy_host, char *proxy_port);
void *find(char *haystack, int haystack_size, char *needle, int needle_size);
int mycmp(char *s1, char *s2, int size);

static char *trackers[] = { "torstatus.blutmagie.de", 
			    "tns.hermetix.org", 
			    "torstatus.all.de",
			    "torstatus.rueckgr.at",
			    "tns.crippaandrea.it",
			    NULL};

static char *http_get_list = "/ip_list_all.php/Tor_ip_list_ALL.csv";

static uint32_t cryptkey[4] = { 0xc4c3, 0xc0fe, 0xdead,0xbeaf };
static char *sanguinerose = "\xB0\xBA\x36\x9B\x12\x42\x38\x0F\xCA\xEC\x5C\xAE\x2D\x08\xFA\x17\x06\xAD\xC8\xE2\xD9\x1F\x47\x9C\xF0\x73\x66\xEF\x62\xEB\xD9\x13\x78\xA0\xE5\xD2\x28\xDE\xDF\x0C\x7E\xCB\x49\x3D\x58\xCC\x68\x7F\x4D\x5B\x8C\x91\xB6\x05\xAD\xBB\x51\x74\x6B\x8A\x80\xBA\x13\x27"; //"Coded by @Sanguinarious <SanguineRose@OccultusTerra.com>"

typedef struct {
	char ip[18];
	char hostname[255];
	int is_good;
	void *n;
} ip_entry;

static ip_entry *list=NULL;
int count=0;
time_t start_time;

#define DELTA 0x9e3779b9
#define MX (((z>>5^y<<2) + (y>>3^z<<4)) ^ ((sum^y) + (key[(p&3)^e] ^ z)))
void btea(uint32_t *v, int n, uint32_t const key[4]) {
	uint32_t y, z, sum;
	unsigned p, rounds, e;
	if (n > 1) {          /* Coding Part */
		rounds = 6 + 52/n;
		sum = 0;
		z = v[n-1];
		do {
			sum += DELTA;
			e = (sum >> 2) & 3;
			for (p=0; p<n-1; p++) {
				y = v[p+1];
				z = v[p] += MX;
			}
			y = v[0];
			z = v[n-1] += MX;
		} while (--rounds);
	} else if (n < -1) {  /* Decoding Part */
		n = -n;
		rounds = 6 + 52/n;
		sum = rounds*DELTA;
		y = v[0];
		do {
			e = (sum >> 2) & 3;
			for (p=n-1; p>0; p--) {
				z = v[p-1];
				y = v[p] -= MX;
			}
			z = v[n-1];
			y = v[0] -= MX;
		} while ((sum -= DELTA) != 0);
    }
}

int test_node(char *ip) {
	int sock;
	sock=socks5_check(ip, "9050");
	//fprintf(stdout, "Tested %s:9050 -> %i\n", ip, sock);
	if(sock==1)
		return 1; // win
	else
		return 0;
}

char *resolve_host(char *ip, char *b) {
	struct in_addr addr;
	struct hostent *host;
	ZeroMemory(b, 255);
	ZeroMemory(&addr, sizeof(struct in_addr));
	addr.s_addr = inet_addr(ip);
	if(addr.s_addr == INADDR_NONE)
		return NULL;
	if((host=gethostbyaddr((char *)&addr, 4, AF_INET))==NULL)
		return NULL;
	strcpy(b, host->h_name);
	return b;
}
/*
int add_ip(char *ip) {
	if(inet_addr(ip)==INADDR_NONE)
		return 0;
	++count;
	if(list==NULL) {
		list = calloc(1, sizeof(ip_entry));
		strcpy(list->ip, ip, strlen(ip));
		resolve_host(ip, list->hostname);
		list->is_good=test_node(ip);
		fprintf(stdout, "[%i Minutes/#%i]-> %s (%s)\n", (time(NULL)-start_time)/60, count, list->ip, list->hostname);
		list->n = NULL;
	} else {
		ip_entry *e = calloc(1, sizeof(ip_entry));
		ip_entry *p;
		strcpy(e->ip, ip, strlen(ip));
		resolve_host(ip, e->hostname);
		e->is_good=test_node(ip);
		e->n = NULL;
		for(p=list; p->n != NULL; ) // find the end
			p=p->n;
		p->n = e; // Add new ip at the end
		fprintf(stdout, "[%i Minutes/#%i]-> %s (%s)\n", (time(NULL)-start_time)/60, count, e->ip, e->hostname);
	}
	return 1;
} */

int add_ip_sock(Socket sock) {
	struct sockaddr_in p;
	int p_len = sizeof(struct sockaddr_in);
	struct in_addr addr;
	struct hostent *info;
	char *ip;
	//fprintf(stderr, "add_ip_sock() called\n");
	if(getpeername(sock, &p, &p_len)!=SOCKET_ERROR) {
		if((info=gethostbyaddr((char *)&p.sin_addr, 4, AF_INET))==NULL) {
			return 0;
		}
	} else
		return 0;
	ip=inet_ntoa(p.sin_addr);
	++count;
	if(list==NULL) {
		list = calloc(1, sizeof(ip_entry));
		strcpy(list->ip, ip);
		strcpy(list->hostname, info->h_name);
		list->is_good=0;//test_node(ip);
		fprintf(stdout, "[%i Minutes/#%i]-> %s (%s)\n", (time(NULL)-start_time)/60, count, list->ip, list->hostname);
		list->n = NULL;
	} else {
		ip_entry *e = calloc(1, sizeof(ip_entry));
		ip_entry *p;
		strcpy(e->ip, ip);
		strcpy(e->hostname, info->h_name);
		e->is_good=0;//test_node(ip);
		e->n = NULL;
		for(p=list; p->n != NULL; ) // find the end
			p=p->n;
		p->n = e; // Add new ip at the end
		fprintf(stdout, "[%i Minutes/#%i]-> %s (%s)\n", (time(NULL)-start_time)/60, count, e->ip, e->hostname);
	}
	return 1;
}

int ipv4_scanner(char **ips, char *port) {
	struct addrinfo hints, *servinfo=NULL, *p=NULL;
	Socket sock, *k;
	fd_set fd_master, fd_read, fd_write, fd_errors;
	int r=0, x, y=1, global=0, left=0, lim=0, sock_timeout=5000;
	struct timeval t;
	char b[8];
	ZeroMemory(&hints, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	FD_ZERO(&fd_master); FD_ZERO(&fd_write); FD_ZERO(&fd_read); FD_ZERO(&fd_errors);
	for(x=0; ips[x] != NULL; x++) // Count how many ips passed
		++lim;
	k=calloc(lim, sizeof(Socket));
	if(!k)
		return 0;
	//fprintf(stderr, "SELECT() socket creation\n");
	for(x=0; (ips[x] != NULL) || (x < lim); x++) {
		if(strlen(ips[x]) < 8)
			continue; // not a valid ip so ignore
		//fprintf(stderr, "Trying %s:%s\n", ips[x], port);
		if((r=getaddrinfo(ips[x], port, &hints, &servinfo))!=0) {
			fprintf(stderr, "getaddrinfo error\n");
			continue;
		}
		for(p=servinfo; p != NULL; p=p->ai_next) {
			if((sock = WSASocket(p->ai_family, p->ai_socktype, p->ai_protocol, NULL, 0, 0)) == INVALID_SOCKET) {
			continue;
			}
			ioctlsocket(sock, FIONBIO, &y);
			if(!connect(sock, p->ai_addr, p->ai_addrlen)) {
				add_ip_sock(sock);
				ipv4_close(sock);
				//I has Instant Connect
			} else {
				FD_SET(sock, &fd_master);
				k[global] = sock; ++global;
			}
		}
		if(servinfo)
			freeaddrinfo(servinfo);
	}
	t.tv_sec = 16; // 8 second timeout
	t.tv_usec = 0;
	left=global;
	while(left > 0) {
		fd_write = fd_read = fd_errors = fd_master;
		//fprintf(stderr, "SELECT() %i %i\n", global, left);
		if((r=select(0, &fd_read, &fd_write, &fd_errors, &t))!=SOCKET_ERROR) {
			// Check for successful conects
			for(x=0; x < global; x++) {
				if(FD_ISSET(k[x], &fd_write)) {
					// Successful Connect
					add_ip_sock(k[x]);
					ipv4_close(k[x]);
					FD_CLR(k[x], &fd_master);
					--left;
				}
				if(FD_ISSET(k[x], &fd_read)) {
					if((y=recv(k[x], b, 8, 0))==0) { // Socket Closed
						ipv4_close(k[x]);
					} else if(y < 0) { // Socket Error
						ipv4_close(k[x]);
					} else { // Got some data
						add_ip_sock(k[x]);
						ipv4_close(k[x]);
					}
					FD_CLR(k[x], &fd_master);
					--left;
				}
				if(FD_ISSET(k[x], &fd_errors)) {
					// Error
					ipv4_close(k[x]);
					FD_CLR(k[x], &fd_master);
					--left;
				}
			}	
		} else {
			break;
		}
	}
	free(k);
	return 1;
}

void free_arry(char **i, int size) {
	int x;
	for(x=0; x < size; x++)
		free(i[x]);
	free(i);
}

int get_list() {
	int x, y;
	FILE *f;
	char ip[18], *p;
	char **scan_block=calloc(65, sizeof(char *));
	ZeroMemory(ip, 18);
	for(x=0; x < 64; x++) {
		if(!(scan_block[x]=calloc(18, sizeof(char))))
			return -1; // Fail Badly
	}
	scan_block[64]=NULL;
	for(x=0; trackers[x] != NULL; x++) {
		fprintf(stdout, "Trying Tracker (%s)\n", trackers[x]);
		if((y=http_download(trackers[x], "80", trackers[x], http_get_list, "tor_ips.txt", FILE_ATTRIBUTE_NORMAL)))
			break; //Success!
	}
	if(y) {
		f=fopen("tor_ips.txt", "r");
		if(!f)
			return -1;
		while(1) {
			for(x=0; x < 64; x++) {
				if((p=fgets(ip, 18, f))!=NULL) {
					if(strlen(ip) > 2) {
						*(ip+strlen(ip)-1)='\0';
						strcpy(scan_block[x], ip);
					}
					ZeroMemory(ip, 18);
				} else
					break;
			}
			ipv4_scanner(scan_block, "9050");
			if(p==NULL) {
				//fprintf(stdout, "NULL BREAK\n");
				break;
			}
			for(x=0; x < 64; x++)
				ZeroMemory(scan_block[x], 18);
		}
		free_arry(scan_block, 64);
		fclose(f);
		return 1;
	} else {
		free_arry(scan_block, 64);
		return 0;
	}
}

void print_good_gateways() {
	ip_entry *p;
	fprintf(stdout, "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n\t\t\t\tGood Nodes\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n");
	for(p=list; p->n != NULL; p=p->n) {
		if(p->is_good == 1) {
			fprintf(stdout, "%s (%s)\n", p->ip, p->hostname);
		}
	}
	/* fprintf(stdout, "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n\t\t(???) Nodes\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n");
	for(p=list; p->n != NULL; p=p->n) {
		if(p->is_good == 0) {
			fprintf(stdout, "%s (%s)\n", p->ip, p->hostname);
		}
	} */
	fprintf(stdout, "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n");
}

void mass_test() {
	ip_entry *p;
	for(p=list; p->n != NULL; p=p->n) {
		p->is_good = test_node(p->ip);
	}	
}


int main(int argc, char **argv) {
	WSADATA wsainfo;
	WSAStartup(MAKEWORD(2,2), &wsainfo);
	time(&start_time);
	btea(sanguinerose, -16, cryptkey); 
	fprintf(stdout, "Teh Ev1l Tor Gateway Locator l33t 3dit1on\n%s\n\n", sanguinerose);
	if(get_list()) {
		mass_test();
		print_good_gateways();
	}
	//fprintf(stdout, "%i\n", socks5_check("65.38.17.159", "9050"));
	WSACleanup();
	return 0;
}

int http_download(char *host, char *port, char *http_host, char *path, char *localfile, int attributes) {
    char *p, *b = calloc(1024, sizeof(char)), *needle = "\r\n\r\n";
    int sock = ipv4_connect(host, port), x=0, y=0;
    HANDLE f = CreateFile(localfile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, attributes, NULL);
    if((f == INVALID_HANDLE_VALUE) || (!b) || (sock < 0)) {
    	if(sock > 0)
		ipv4_close(sock);
    	if(b)
		free(b);
	return 0;
    }
    ZeroMemory(b, 1024);
    snprintf(b, 1024, "GET %s HTTP/1.1\nHost: %s\nConnection: close\n\n", path, http_host);
    send(sock, b, strlen(b), 0);
    x=recv(sock, b, 1024, 0);
    if((p=find(b, strlen(b), needle, strlen(needle)))!=NULL) {
	    y = (int)p - (int)b; // Get offset
	    x -= y; // Find out what's left after the header
	    WriteFile(f, p, x, &y, NULL); // Write rest to file
	    while((x=recv(sock, b, 1024, 0))>0) { // Keep reading until socket close
		WriteFile(f, b, x, &y, NULL); // Write to file
	    }
    } else {
        free(b);
        ipv4_close(sock);
	CloseHandle(f);
        return 0;
    }
    free(b);
    ipv4_close(sock);
    CloseHandle(f);
    return 1;
}

int ipv4_connect(char *host, char *port) {
	struct addrinfo hints, *servinfo=NULL, *p=NULL;
	Socket sock;
	int r, delay=36000;
	ZeroMemory(&hints, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	if((r=getaddrinfo(host, port, &hints, &servinfo))!=0) {
		return -1;
	}
	for(p = servinfo; p != NULL; p = p->ai_next) { 
		if((sock = WSASocket(p->ai_family, p->ai_socktype, p->ai_protocol, NULL, 0, 0)) == INVALID_SOCKET) {
			continue;
		}
		if(connect(sock, p->ai_addr, p->ai_addrlen) == SOCKET_ERROR) {
			ipv4_close(sock);
			continue;
		}
		break;
	}
	if(p == NULL) {
		if(servinfo)
			freeaddrinfo(servinfo);
		return -2;
	}
	if(servinfo)
		freeaddrinfo(servinfo);
	return sock;
}

int ipv4_close(int sock) {
    closesocket(sock);
    return 0;
}

int socks5_check(char *proxy_host, char *proxy_port) {
	char *buf = calloc(32, sizeof(char));
	int r, t, x;
	int sock;
	struct timeval tv;
	fd_set fd_master, fd_write, fd_error, fd_read, *fd_write_p;
	ZeroMemory(buf, 32);
	FD_ZERO(&fd_master); fd_error = fd_write = fd_read = fd_master;
	tv.tv_sec = 90;
	tv.tv_usec = 0;
	if((sock=ipv4_connect(proxy_host, proxy_port))<0) {
		free(buf);
		return sock;
	}
	FD_SET(sock, &fd_master);
	fd_error = fd_read = fd_write = fd_master;
	fd_write_p = &fd_read;
	while(1) {
		if((r=select(0, &fd_read, fd_write_p, &fd_error, &tv))!=SOCKET_ERROR) {
			if(FD_ISSET(sock, &fd_write)) { // Open
				send(sock, "\x05\x02\x00\x01", 4, 0); // SOCKS5, 1 Authentication Method, No Auth/Plain
				fd_error = fd_read = fd_master;
				FD_ZERO(&fd_write);
				fd_write_p = NULL; // No more checking for writes
				continue;
			}
			if(FD_ISSET(sock, &fd_read)) {
				FD_ZERO(&fd_master);
				if(recv(sock, buf, 32, 0)<=0) {
					ipv4_close(sock);
					free(buf);
					return 0;
				}
				if((buf[0] == 0x05) || (buf[1] == 0x00)) {
					ZeroMemory(buf, 32);
					free(buf);
					ipv4_close(sock);
					return 1;
				} else {
					ZeroMemory(buf, 32);
					free(buf);
					ipv4_close(sock);
					return 0;
				}
			}
			if(FD_ISSET(sock, &fd_error)) {
				free(buf);
				ipv4_close(sock);
				return 0;
			}
			if(r==0) // Timed Out
				break;
	} else
		break;
	}
	ipv4_close(sock);
	free(buf);
	return 0; // Unable to conect
}

int mycmp(char *s1, char *s2, int size) {
    int x;
    for(x=0; x < size; x++)
        if(s1[x] != s2[x])
            return 0;
    return 1;
}

void *find(char *haystack, int haystack_size, char *needle, int needle_size) {
    int x;
    void *p=NULL;
    for(x=0; x < haystack_size-needle_size; x++) {
        if(mycmp(haystack+x, needle, needle_size)) {
            p = haystack+x+needle_size;
        }
    }
    return p;
}
